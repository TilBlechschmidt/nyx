/*
    Nyx, blazing fast astrodynamics
    Copyright (C) 2023 Christopher Rabotin <christopher.rabotin@gmail.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

use std::collections::{HashMap, HashSet};
use std::error::Error;
use std::fmt::Display;
use std::fs::File;
use std::path::Path;
use std::sync::Arc;

use crate::io::watermark::pq_writer;
use crate::linalg::allocator::Allocator;
use crate::linalg::{DefaultAllocator, DimName};
use crate::od::Measurement;
use arrow::array::{ArrayRef, Float64Array, StringArray};
use arrow::datatypes::{DataType, Field, Schema};
use arrow::record_batch::RecordBatch;
use parquet::arrow::ArrowWriter;

/// Tracking arc contains the tracking data generated by the tracking devices defined in this structure.
/// This structure is shared between both simulated and real tracking arcs.
#[derive(Clone, Debug)]
pub struct TrackingArc<Msr>
where
    Msr: Measurement,
    DefaultAllocator: Allocator<f64, Msr::MeasurementSize>,
{
    // Returns the observation at the provided epoch.
    /// A list of the serialized devices.
    pub devices: Vec<String>,
    /// A chronological list of the measurements to the devices used to generate these measurements. If the name of the device does not appear in the list of devices, then the measurement will be ignored.
    pub measurements: Vec<(String, Msr)>,
}

impl<Msr> Display for TrackingArc<Msr>
where
    Msr: Measurement,
    DefaultAllocator: Allocator<f64, Msr::MeasurementSize>,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut set = HashSet::new();
        self.measurements.iter().for_each(|(name, _msr)| {
            set.insert(name);
        });
        write!(f, "{} measurements from {:?}", self.measurements.len(), set)
    }
}
impl<Msr> TrackingArc<Msr>
where
    Msr: Measurement,
    DefaultAllocator: Allocator<f64, Msr::MeasurementSize>,
{
    /// Store this tracking arc to a parquet file
    /// TODO: Support time stamp in file name and shadow-rs info in metadata
    pub fn write_parquet<P: AsRef<Path>>(&self, path: P) -> Result<P, Box<dyn Error>> {
        // Build the schema
        let mut hdrs = vec![
            Field::new("Epoch Gregorian UTC", DataType::Utf8, false),
            Field::new("Epoch Gregorian TDB", DataType::Utf8, false),
            Field::new("Epoch TDB seconds", DataType::Float64, false),
            Field::new("Tracking device", DataType::Utf8, false),
        ];

        let mut msr_fields = Msr::fields();

        hdrs.append(&mut msr_fields);

        // Build the schema
        let schema = Arc::new(Schema::new(hdrs));
        let mut record = Vec::new();

        // Build all of the records
        record.push(Arc::new(StringArray::from(
            self.measurements
                .iter()
                .map(|m| format!("{}", m.1.epoch()))
                .collect::<Vec<String>>(),
        )) as ArrayRef);

        record.push(Arc::new(StringArray::from(
            self.measurements
                .iter()
                .map(|m| format!("{:e}", m.1.epoch()))
                .collect::<Vec<String>>(),
        )) as ArrayRef);

        record.push(Arc::new(Float64Array::from(
            self.measurements
                .iter()
                .map(|m| m.1.epoch().to_tdb_seconds())
                .collect::<Vec<f64>>(),
        )) as ArrayRef);

        record.push(Arc::new(StringArray::from(
            self.measurements
                .iter()
                .map(|m| m.0.clone())
                .collect::<Vec<String>>(),
        )) as ArrayRef);

        // Now comes the measurement data

        for obs_no in 0..Msr::MeasurementSize::USIZE {
            record.push(Arc::new(Float64Array::from(
                self.measurements
                    .iter()
                    .map(|m| m.1.observation()[obs_no])
                    .collect::<Vec<f64>>(),
            )) as ArrayRef);
        }

        // Serialize all of the devices and add that to the parquet file too.
        let mut metadata = HashMap::new();
        metadata.insert("devices".to_string(), self.devices.join("\n"));
        metadata.insert("Purpose".to_string(), "Tracking Arc Data".to_string());

        let props = pq_writer(Some(metadata));
        let file = File::create(&path)?;
        let mut writer = ArrowWriter::try_new(file, schema.clone(), props).unwrap();

        let batch = RecordBatch::try_new(schema, record)?;
        writer.write(&batch)?;
        writer.close()?;

        // Return the path this was written to
        Ok(path)
    }
}
